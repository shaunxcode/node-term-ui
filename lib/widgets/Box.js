// Generated by CoffeeScript 1.6.1
(function() {
  var B, T, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  _.mixin(require("underscore.string"));

  T = require("../TermUI");

  B = require("../boxChars");

  T.Box = (function(_super) {

    __extends(Box, _super);

    function Box(opts) {
      var _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (opts == null) {
        opts = {};
      }
      this.renderChar = (_ref = opts.renderChar) != null ? _ref : false;
      this.ellipsizeContent = (_ref1 = opts.ellipsizeContent) != null ? _ref1 : true;
      this.hideScrollers = (_ref2 = opts.hideScrollers) != null ? _ref2 : false;
      this.content = (_ref3 = opts.content) != null ? _ref3 : [];
      this.children = (_ref4 = opts.children) != null ? _ref4 : [];
      if ((opts.borders != null) && !opts.borders) {
        this.borders = {
          l: false,
          r: false,
          t: false,
          b: false
        };
      } else {
        this.borders = _.extend({
          l: true,
          r: true,
          t: true,
          b: true
        }, (_ref5 = opts.borders) != null ? _ref5 : {});
      }
      this.vbdiff = 0;
      this.hbdiff = 0;
      if (this.borders.l) {
        this.hbdiff++;
      }
      if (this.borders.r) {
        this.hbdiff++;
      }
      if (this.borders.t) {
        this.vbdiff++;
      }
      if (this.borders.b) {
        this.vbdiff++;
      }
      Box.__super__.constructor.call(this, opts);
      this.scrollPos = 0;
      this.scrollPosX = 0;
      this.rightBorderChar = this.borders.r ? B(0, 0, 1, 1) : "";
      this.leftBorderChar = this.borders.l ? B(0, 0, 1, 1) : "";
      if (opts.roundedCorners) {
        this.topLeftCorner = B(0, 6, 0, 6);
        this.topRightCorner = B(6, 0, 0, 6);
        this.botLeftCorner = B(0, 6, 6, 0);
        this.botRightCorner = B(6, 0, 6, 0);
      } else {
        this.topLeftCorner = B(0, 1, 0, 1);
        this.topRightCorner = B(1, 0, 0, 1);
        this.botLeftCorner = B(0, 1, 1, 0);
        this.botRightCorner = B(1, 0, 1, 0);
      }
      this.borderColor = (_ref6 = opts.borderColor) != null ? _ref6 : T.C.g;
      this.contentColor = (_ref7 = opts.contentColor) != null ? _ref7 : T.C.g;
      this.calcDims();
    }

    Box.prototype.calcDims = function() {
      var child, k, nh, nw, v, _i, _j, _k, _l, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results, _results1;
      _ref = this.bounds;
      for (k in _ref) {
        v = _ref[k];
        this.bounds[k] = Math.floor(v);
      }
      if (this.content.length) {
        T._d(this.content);
        this.widestContent = _.last(_.sortBy(this.content, function(c) {
          return c.length;
        })).length;
      } else {
        this.widestContent = 0;
      }
      if (((_ref1 = this.options.bounds) != null ? _ref1.w : void 0) === "fit") {
        if (this.content.length) {
          this.bounds.w = this.widestContent + this.hbdiff;
        } else {
          this.bounds.w = this.widestContent;
        }
        _ref2 = this.children;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          child = _ref2[_i];
          if ((nw = child.bounds.x + child.bounds.w + child.hbdiff) > this.bounds.w) {
            this.bounds.w = nw;
          }
        }
      }
      if (((_ref3 = this.options.bounds) != null ? _ref3.h : void 0) === "fit") {
        if (this.content.length) {
          this.bounds.h = this.content.length + this.vbdiff;
        } else {
          this.bounds.h = 0;
        }
        _ref4 = this.children;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          child = _ref4[_j];
          if ((nh = child.bounds.y + child.bounds.h + child.vbdiff) > this.bounds.h) {
            this.bounds.h = nh;
          }
        }
      }
      this.maxWidth = this.bounds.w - this.hbdiff;
      this.maxHeight = this.bounds.h - this.vbdiff;
      this.maxScrollY = this.bounds.y + this.maxHeight;
      this.maxScrollX = this.bounds.x + this.maxWidth;
      this.contentRangeY = (function() {
        _results = [];
        for (var _k = _ref5 = this.bounds.y + 1, _ref6 = this.bounds.y + this.maxHeight; _ref5 <= _ref6 ? _k <= _ref6 : _k >= _ref6; _ref5 <= _ref6 ? _k++ : _k--){ _results.push(_k); }
        return _results;
      }).apply(this);
      this.rightBorderX = this.bounds.x + this.bounds.w - (this.borders.l ? 1 : 0);
      _ref7 = this.children;
      _results1 = [];
      for (_l = 0, _len2 = _ref7.length; _l < _len2; _l++) {
        child = _ref7[_l];
        child.bounds.x += this.bounds.x;
        child.bounds.y += this.bounds.y;
        _results1.push(child.calcDims());
      }
      return _results1;
    };

    Box.prototype.setContent = function(content) {
      this.content = content;
      this.calcDims();
      this.draw();
      return this;
    };

    Box.prototype.setBounds = function(bounds) {
      _.extend(this.bounds, bounds);
      this.calcDims();
      this.draw();
      return this;
    };

    Box.prototype.setBorderColor = function(c) {
      this.borderColor = c;
      return this;
    };

    Box.prototype.draw = function() {
      if (this.hidden) {
        return;
      }
      this.drawBorders();
      this.drawContent();
      return Box.__super__.draw.call(this);
    };

    Box.prototype.drawBorders = function() {
      var row, _i, _len, _ref;
      T.hideCursor().saveFg().fg(this.borderColor);
      if (this.borders.t) {
        T.pos(this.bounds.x, this.bounds.y).out(this.borders.l ? this.topLeftCorner : B(1, 1, 0, 0)).out(_.repeat(B(1, 1, 0, 0), this.bounds.w - this.hbdiff)).out(this.borders.r ? this.topRightCorner : B(1, 1, 0, 0));
      }
      if (this.borders.b) {
        T.pos(this.bounds.x, this.bounds.y + this.bounds.h - (Math.floor(this.vbdiff / 2))).out(this.borders.l ? this.botLeftCorner : B(0, 0, 1, 1)).out(_.repeat(B(1, 1, 0, 0), this.bounds.w - this.hbdiff)).out(this.borders.r ? this.botRightCorner : B(1, 1, 0, 0));
      }
      _ref = this.contentRangeY;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        T.pos(this.bounds.x, row).out(this.leftBorderChar).pos(this.rightBorderX, row).out(this.rightBorderChar);
      }
      T.restoreFg();
      if (this.content.length > this.maxHeight) {
        this.scroll(0);
      }
      return this.emit("bordersDrawn");
    };

    Box.prototype._drawRow = function(x, y, content, index) {
      var c, _i, _len;
      T.saveFg().saveBg().pos(x, y);
      if (this.renderChar) {
        for (_i = 0, _len = content.length; _i < _len; _i++) {
          c = content[_i];
          if ((c != null ? c.char : void 0) != null) {
            T.fg(c.fg).bg(c.bg).out(c.char);
          } else {
            T.out(" ");
          }
        }
      } else {
        T.fg(this.contentColor).out(content);
      }
      T.restoreFg().restoreBg();
      return this;
    };

    Box.prototype.drawContent = function() {
      var c, ci, content, l, line, x, _i, _len, _ref;
      l = 0;
      c = 0;
      this.n = 35;
      x = this.bounds.x + (this.borders.l ? 1 : 0);
      _ref = this.contentRangeY;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        ci = this.scrollPos + l++;
        content = "";
        if (this.content[ci] != null) {
          content = this.content[ci].slice(this.scrollPosX);
        }
        if (content.length > this.maxWidth) {
          if (this.ellipsizeContent) {
            content = content.slice(0, +(this.maxWidth - 3) + 1 || 9e9) + "..";
          } else {
            content = content.slice(0, +(this.maxWidth - 1) + 1 || 9e9);
          }
        } else if (_.isString(content)) {
          content = _.rpad(content, this.maxWidth, " ");
        }
        this._drawRow(x, line, content, ci);
      }
      this.drawChildren();
      this.emit("contentDrawn");
      return this;
    };

    Box.prototype.drawChildren = function() {
      var child, _i, _len, _ref;
      _ref = this.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        child.draw();
      }
      return this;
    };

    Box.prototype._scrollX = function() {
      var per;
      if (this.scrollPosX === this.widestContent - this.maxWidth) {
        return this.maxScrollX;
      } else {
        per = this.scrollPosX / (this.widestContent - this.maxWidth + 1);
        return this.bounds.x + Math.floor(this.maxWidth * per) + 1;
      }
    };

    Box.prototype._scrollY = function() {
      var per;
      if (this.scrollPos === this.content.length - this.maxHeight) {
        return this.maxScrollY;
      } else {
        per = this.scrollPos / (this.content.length - this.maxHeight + 1);
        return this.bounds.y + Math.floor(this.maxHeight * per) + 1;
      }
    };

    Box.prototype.hasScrollableContent = function() {
      return this.content.length > this.maxHeight;
    };

    Box.prototype.scroll = function(byAmt) {
      if (this.content.length !== 0 && !this.hideScrollers && this.hasScrollableContent()) {
        T.saveFg().fg(this.borderColor);
        T.pos(this.rightBorderX, this._scrollY()).out(this.rightBorderChar);
        this.scrollPos += byAmt;
        T.pos(this.rightBorderX, this._scrollY()).out(B(0, 0, 3, 3));
        T.restoreFg();
      } else {
        this.scrollPos += byAmt;
      }
      return this.drawContent();
    };

    Box.prototype.scrollX = function(byAmt) {
      this.scrollPosX += byAmt;
      return this.drawContent();
    };

    Box.prototype.onKey_up = function() {
      if (this.content.length === 0) {
        return;
      }
      if (this.scrollPos === 0) {
        return this.scroll(0);
      } else {
        return this.scroll(-1);
      }
    };

    Box.prototype.onKey_down = function() {
      if (this.content.length === 0) {
        return;
      }
      if ((this.scrollPos === this.content.length - this.maxHeight) || (!this.hasScrollableContent())) {
        return this.scroll(0);
      } else {
        return this.scroll(1);
      }
    };

    Box.prototype.onKey_left = function() {
      if (this.content.length === 0) {
        return;
      }
      if (this.scrollPosX === 0) {
        return this.scrollX(0);
      } else {
        return this.scrollX(-1);
      }
    };

    Box.prototype.onKey_right = function() {
      if (this.content.length === 0) {
        return;
      }
      if (this.scrollPosX === this.widestContent - this.maxWidth) {
        return this.scrollX(0);
      } else {
        return this.scrollX(1);
      }
    };

    Box.prototype.focus = function() {
      Box.__super__.focus.call(this);
      this.setBorderColor(T.C.y);
      this.drawBorders();
      return this;
    };

    Box.prototype.blur = function() {
      Box.__super__.blur.call(this);
      this.setBorderColor(T.C.g);
      return this.drawBorders();
    };

    return Box;

  })(T.Widget);

}).call(this);
