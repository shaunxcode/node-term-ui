// Generated by CoffeeScript 1.6.1
(function() {
  var B, T, _, _d, _dl,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ = require("underscore");

  _.mixin(require("underscore.string"));

  T = require("../TermUI");

  B = require("../boxChars");

  _dl = 20;

  _d = function(x) {
    T.pos(1, _dl++).eraseLine().out("" + _dl + ":" + (JSON.stringify(x)));
    if (_dl > 30) {
      return _dl = 19;
    }
  };

  T.Box = (function(_super) {

    __extends(Box, _super);

    function Box(opts) {
      var _i, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
      Box.__super__.constructor.call(this, opts);
      if ((opts.borders != null) && !opts.borders) {
        this.borders = {
          l: false,
          r: false,
          t: false,
          b: false
        };
      } else {
        this.borders = _.extend({
          l: true,
          r: true,
          t: true,
          b: true
        }, (_ref = opts.borders) != null ? _ref : {});
      }
      this.content = (_ref1 = opts.content) != null ? _ref1 : [];
      this.scrollPos = 0;
      this.vbdiff = 0;
      this.hbdiff = 0;
      if (this.borders.l) {
        this.hbdiff++;
      }
      if (this.borders.r) {
        this.hbdiff++;
      }
      if (this.borders.t) {
        this.vbdiff++;
      }
      if (this.borders.b) {
        this.vbdiff++;
      }
      this.maxWidth = this.bounds.w - this.hbdiff;
      this.maxHeight = this.bounds.h - this.vbdiff;
      this.maxScrollY = this.bounds.y + this.maxHeight;
      this.contentRange = (function() {
        _results = [];
        for (var _i = _ref2 = this.bounds.y + 1, _ref3 = this.bounds.y + this.maxHeight; _ref2 <= _ref3 ? _i <= _ref3 : _i >= _ref3; _ref2 <= _ref3 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this);
      this.rightBorderX = this.bounds.x + this.bounds.w - (this.borders.l ? 1 : 0);
      this.rightBorderChar = this.borders.r ? B(0, 0, 1, 1) : "";
      this.leftBorderChar = this.borders.l ? B(0, 0, 1, 1) : "";
      this.borderColor = (_ref4 = opts.borderColor) != null ? _ref4 : T.C.g;
      this.contentColor = (_ref5 = opts.contentColor) != null ? _ref5 : T.C.g;
    }

    Box.prototype.setBorderColor = function(c) {
      this.borderColor = c;
      return this;
    };

    Box.prototype.draw = function() {
      this.drawBorders();
      this.drawContent();
      return Box.__super__.draw.call(this);
    };

    Box.prototype.drawBorders = function() {
      var row, _i, _len, _ref;
      T.hideCursor().saveFg().fg(this.borderColor);
      if (this.borders.t) {
        T.pos(this.bounds.x, this.bounds.y).out(this.borders.l ? B(0, 1, 0, 1) : B(1, 1, 0, 0)).out(_.repeat(B(1, 1, 0, 0), this.bounds.w - this.hbdiff)).out(this.borders.r ? B(1, 0, 0, 1) : B(1, 1, 0, 0));
      }
      if (this.borders.b) {
        T.pos(this.bounds.x, this.bounds.y + this.bounds.h - 1).out(this.borders.l ? B(0, 1, 1, 0) : B(0, 0, 1, 1)).out(_.repeat(B(1, 1, 0, 0), this.bounds.w - this.hbdiff)).out(this.borders.r ? B(1, 0, 1, 0) : B(1, 1, 0, 0));
      }
      _ref = this.contentRange;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        row = _ref[_i];
        T.pos(this.bounds.x, row).out(this.leftBorderChar).pos(this.rightBorderX, row).out(this.rightBorderChar);
      }
      T.restoreFg();
      if (this.content.length > this.maxHeight) {
        this.scroll(0);
      }
      return this.emit("drawn");
    };

    Box.prototype._drawRow = function(x, y, content, index) {
      T.saveFg().fg(this.contentColor);
      T.pos(x, y).out(content);
      T.restoreFg();
      return this;
    };

    Box.prototype.drawContent = function() {
      var ci, content, l, line, x, _i, _len, _ref, _ref1;
      l = 0;
      x = this.bounds.x + (this.borders.l ? 1 : 0);
      _ref = this.contentRange;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        ci = this.scrollPos + l++;
        content = (_ref1 = this.content[ci]) != null ? _ref1 : "";
        if (content.length > this.maxWidth) {
          content = content.slice(0, +(this.maxWidth - 3) + 1 || 9e9) + "..";
        } else {
          content = _.rpad(content, this.maxWidth, " ");
        }
        this._drawRow(x, line, content, ci);
      }
      this.emit("contentDrawn");
      return this;
    };

    Box.prototype._scrollY = function() {
      var per;
      if (this.scrollPos === this.content.length - this.maxHeight) {
        return this.maxScrollY;
      } else {
        per = this.scrollPos / (this.content.length - this.maxHeight + 1);
        return this.bounds.y + Math.floor(this.maxHeight * per) + 1;
      }
    };

    Box.prototype.scroll = function(byAmt) {
      T.saveFg().fg(this.borderColor);
      T.pos(this.rightBorderX, this._scrollY()).out(this.rightBorderChar);
      this.scrollPos = this.scrollPos + byAmt;
      T.pos(this.rightBorderX, this._scrollY()).out(B(0, 0, 3, 3));
      T.restoreFg();
      return this.drawContent();
    };

    Box.prototype.onKey_up = function() {
      if (this.scrollPos === 0) {
        return this.scroll(0);
      } else {
        return this.scroll(-1);
      }
    };

    Box.prototype.onKey_down = function() {
      if (this.scrollPos === this.content.length - this.maxHeight) {
        return this.scroll(0);
      } else {
        return this.scroll(1);
      }
    };

    Box.prototype.focus = function() {
      Box.__super__.focus.call(this);
      this.setBorderColor(T.C.y);
      return this.drawBorders();
    };

    Box.prototype.blur = function() {
      Box.__super__.blur.call(this);
      this.setBorderColor(T.C.g);
      return this.drawBorders();
    };

    return Box;

  })(T.Widget);

}).call(this);
